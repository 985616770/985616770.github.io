---
title: JavaScript-面向对象
date: 2019-11-18 23:47:04
tags:
  - 正则表达式
  - JavaScript
categories: JavaScript
---

# 正则表达式

> 定义

- 操作字符串
- 查找特定字符
- 替换文本(敏感词过滤)
- 数据有效性验证

<!-- more -->

> 两种字符组成的文字模式

- 普通字符 26 个英文字母数字
- 特殊字符有特殊含义的(`./\~&^*%$@#`)

## 创建

1. 字面量创建

```js
let pattern = /^abc$/gi;
```

2. 构造函数创建

```js
let a = new RegExp('abc', 'ig');
/^function\s*[^\(]*\(\s*([^\)]*)\)/m


```

## 方法

> pattern.test()

- 检测是否存在
- 返回布尔值

> pattern.exec()

- 返回匹配字符串

> 修饰符

- `i`
  - ignoreCase 忽略大小写
- `g`
  - global 全局匹配
- `m`
  - multiline 多行匹配
  - 与\$^ 配合使用

> 转义　`\`

```js
\n 换行 => \xOA
\t tab键 \uooo9
\u4eoo-\u9fa5 中文
```

##　匹配模式

> 字符类

- 匹配单一字符

```js
[] 从方括号中按顺序匹配一个
[^_] 匹配除了下划线之外的所有字符
[a-z] 匹配a到z的所有字母
[A-Z] 匹配大写a到z的所有字母
[\u4E00-\u9FA5] 匹配所有的中文简体字
[0-9] 匹配所有的数字

[a-zA-Z0-9_] = \w 匹配字母加数字和下划线
[^a-zA-Z0-9_] = \W 匹配除了字母加数字和下划线之外的所有字符

[0-9] = \d 匹配所有数字
[^0-9] = \D 匹配除了数字之外的所有字符

\s 匹配空格制表符，unicode码
\S 为除了空格制表符,unicode码

```

> 重复（量词）

```js
{n} 匹配次数n次
{n,m} 匹配次数n到m次
{0,1} => ? 匹配0~1次
{1,+++} => + 匹配一次以上
{0,+++} => * 匹配零次以上

```

> **贪婪匹配**:

- 匹配次数尽量多

```js
加 ? 号 可以变成非贪婪匹配,尽可能少从头开始,
与 重复量词 和 匹配单一字符 进行组合
\d+?
\d??
\d*?

只有在开头不会匹配的情况下，才会达到预期效果

```

> 选择符 `|`

`str | str2 | str3`

- 选择一个进行匹配

> 分组 `()`

1. 返回匹配数组，捕获性分组

```js
let str = 'abcabc';

let pattern = /(ab)c/;

pattern.exec(str); //["abc", "ab", index: 0, input: "abcabc", groups: undefined]
```

2. 非捕获性分组,只匹配第 1 次

- 加上 `?:`

```js
let str = 'abcabc';

let pattern = /(?:ab)/;

pattern.exec(str); //["abc", "ab", index: 0, input: "abcabc", groups: undefined]
```

3. 多个分组按顺序,分布排布

4. 嵌套分组 ((())) 从左括号按顺序分组

5. 分组可用 `\{num}` 代替,属于同一组

- `(ab)cc(ab) => (ab)cc\1`

> 指定位置匹配

- `/^.../`

- `/...$/`

> 单词边界匹配

- `\b` 单词边界 `\w` `\W` 之间的位置
- 匹配单词很好用

```js
str = 'className stu abc';
str.replace(/className\b/, '123'); // "123 stu abc"
```

> 前瞻性匹配 & 后瞻性匹配

- `...(?=word)` 匹配前面，但后边必须紧跟着这个词
- `...(?!word)` 匹配前面，但后边不是这个词

```js
str = 'className';
str.replace(/class(?=Name)/, '123');
// ('123');
str = 'classname';
str.replace(/class(?!Name)/, '123');
// ('123name');
```

## 实例方法

> exec

- 返回一个数组
- 属性
  - index
    - 匹配到的字符索引
  - input - 匹配到的文本
    > test
- 返回布尔值

> toString

- 转化成字符串
  > tolocalString
- 转换为字符串

> valueOf

- 返回自身

- lastIndex
  - 上次匹配到的位置(在全局模式下)
- ignoreCase
  - 布尔值, 是否有 i
- global
  - 布尔值
- multiline
  - 布尔值
- source
  - 返回// 的字符串

## 构造函数

- `[_$]` = input
- `[$&]` = lastMatch
- leftContext = ["$`"]
- rightContext = ["$'"]
- lastParen = ["$+"]
- $1 - $9

## String 对象的正则方法

> search

- 返回 index 没有返回-1

> match

- 返回一个数组
- 类似于 正则表达式 exec

> > 区别 exec match
>
> - (match)非全局的情况下 返回分组中匹配的内容,全局匹配会匹配 返回所有匹配到的字符
> - (exec) 无论是否全局，都要返回分组中匹配到的内容,只会返回一个结果

> split

- 分割字符

> replace

- 第 2 个参数可以是回调，也可以是字符串
- $1-$9

比较强大,可以用它来敏感词过滤.

## 常用的正则表达式

> qq

- 全部是数字首位不为 0，最少 5 位，最多 11 位
- `/^[1-9]\d{4,11}/`

> 昵称

- 中英文下划线 2~18 位
- `^[\u4e00-\u9fa5\w]{2,18}`

> 密码

- 6~16 位不能用空的字符区分大小写
- `[\w]{6,16}`
  > 匹配 html 标签
- 匹配 html 标签,需要注意 闭合标签和非闭合标签
- `/<(?:[^>"']*|"[^"]*"|'[^']*')*>/g`
- `/<(?:[^>"']*|"(["'])[^"']*)*>/g`
  > 邮箱
- 前面的字符不做限制，有@，后边有一个点, 最后全为字母
- `/^(?:\w+\.)*\w+@(?:\w+\.)+[a-z]+/`

  > Url 地址

- 具体来说比较复杂,
- 协议://主机名:端口号/路径
- `/^https?:\/\/)?([^:\/]+)(:\d+)?(\/.*)?$/`
